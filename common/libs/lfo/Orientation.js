"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _BaseLfo = _interopRequireDefault(require("./BaseLfo.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// port of orientation.cpp Max object
const abs = Math.abs;
const atan2 = Math.atan2;
const cos = Math.cos;
const sin = Math.sin;
const sqrt = Math.sqrt;
const pow = Math.pow;
const tan = Math.tan;
const max = Math.max;
const toDeg = 180 / Math.PI;
const toRad = Math.PI / 180;

function normalize(v) {
  const mag = sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);

  if (mag > 0) {
    v[0] /= mag;
    v[1] /= mag;
    v[2] /= mag;
  }

  return v;
}

const parameters = {
  k: {
    type: 'float',
    min: 0,
    max: 1,
    step: 0.01,
    default: 0.9
  }
};
/**
 * Filter that integrate gyrosscope and acceleration in order to remove noise
 * from accelerometers data while keeping a good reactivity.
 * The filter ouputs a normalized projection vector.
 * Be aware that the out of the filter invert the x and z in regard of the
 * device motion specification (left-hand axis). This is done for compatibility
 * with the R-ioT sensor.
 *
 * @memberof operator
 *
 * @param {Object} [options] - Override default options.
 * @param {Number} [options.k=0.9] - Ratio between the accelerometers and gyroscope.
 *  1 means gyroscope only
 *  0 mean accelerometers only (this is equivalent to a lowpass filter)
 *
 * @example
 * import * as lfo from 'waves-lfo/client';
 * import * as lfoMotion from 'lfo-motion';
 *
 * const motionInput = new lfoMotion.source.MotionInput();
 * const sampler = new lfoMotion.operator.Sampler({ frameRate: 50 });
 * const orientation = new lfoMotion.operator.Orientation();
 * const logger = new lfo.sink.Logger({ data: true });
 *
 * motionInput.connect(sampler);
 * sampler.connect(orientation);
 * orientation.connect(logger);
 *
 * motionInput.init().then(() => motionInput.start())
 */

class Orientation extends _BaseLfo.default {
  constructor(options) {
    super(parameters, options);
  }
  /** @private */


  processStreamParams(prevStreamParams) {
    this.prepareStreamParams(prevStreamParams);
    this.streamParams.frameSize = 3;
    this.init = false;
    this.lastTime = 0;
    this.interval = 0; // this.k = 0.9;
    // normalized acceleration vector
    // coordinates are flipped to match R-ioT coords system

    this.accVector = new Float32Array(3); // normalize gyro order and direction according to R-ioT

    this.gyroVector = new Float32Array(3); // third component (yaw) will never be used
    // same as before as a projection vector

    this.gyroEstimate = new Float32Array(3); // filtered vector

    this.accEstimate = new Float32Array(3);
    this.propagateStreamParams();
  }
  /** @private */


  processVector(frame) {
    const time = frame.time;
    const input = frame.data;
    const output = this.frame.data;
    const accEstimate = this.accEstimate;
    const gyroEstimate = this.gyroEstimate;
    const k = this.params.get('k');
    /**
     * Reorder accelerometer and gyro to conform to R-ioT
     * coordinate system and gyro directions
     */

    const accVector = this.accVector;
    const accOffset = 0;
    accVector[0] = -1 * input[0 + accOffset];
    accVector[1] = 1 * input[1 + accOffset];
    accVector[2] = -1 * input[2 + accOffset];
    const gyroVector = this.gyroVector;
    const gyroOffset = 3;
    gyroVector[0] = -1 * input[2 + gyroOffset];
    gyroVector[1] = -1 * input[1 + gyroOffset];
    gyroVector[2] = -1 * input[0 + gyroOffset];
    normalize(accVector);

    if (!this.lastTime) {
      this.lastTime = time; // initialize corrected orientation with normalized accelerometer data

      for (let i = 0; i < 3; i++) {
        accEstimate[i] = accVector[i];
      }

      return;
    } else {
      // define if we use that or use the logical `MotionEvent.interval`
      const dt = time - this.lastTime;
      this.lastTime = time; // integrate angle from gyro current values and last result
      // get angles between projection of R on ZX/ZY plane and Z axis, based on last accEstimate
      // gyroVector in deg/s, delta and angle in rad

      const rollDelta = gyroVector[0] * dt * toRad;
      const rollAngle = atan2(accEstimate[0], accEstimate[2]) + rollDelta;
      const pitchDelta = gyroVector[1] * dt * toRad;
      const pitchAngle = atan2(accEstimate[1], accEstimate[2]) + pitchDelta; // calculate projection vector from angle Estimates

      gyroEstimate[0] = sin(rollAngle);
      gyroEstimate[0] /= sqrt(1 + pow(cos(rollAngle), 2) * pow(tan(pitchAngle), 2));
      gyroEstimate[1] = sin(pitchAngle);
      gyroEstimate[1] /= sqrt(1 + pow(cos(pitchAngle), 2) * pow(tan(rollAngle), 2)); // estimate sign of RzGyro by looking in what qudrant the angle Axz is,
      // RzGyro is positive if  Axz in range -90 ..90 => cos(Awz) >= 0

      const signYaw = cos(rollAngle) >= 0 ? 1 : -1; // estimate yaw since vector is normalized

      const gyroEstimateSquared = pow(gyroEstimate[0], 2) + pow(gyroEstimate[1], 2);
      gyroEstimate[2] = signYaw * sqrt(max(0, 1 - gyroEstimateSquared)); // interpolate between estimated values and raw values

      for (let i = 0; i < 3; i++) {
        accEstimate[i] = gyroEstimate[i] * k + accVector[i] * (1 - k);
      }

      normalize(accEstimate); // Rz is too small and because it is used as reference for computing Axz, Ayz
      // it's error fluctuations will amplify leading to bad results. In this case
      // skip the gyro data and just use previous estimate

      if (abs(accEstimate[2]) < 0.1) {
        // use input instead of estimation
        // accVector is already normalized
        for (let i = 0; i < 3; i++) {
          accEstimate[i] = accVector[i];
        }
      }
    }

    output[0] = accEstimate[0];
    output[1] = accEstimate[1];
    output[2] = accEstimate[2];
  }

}

var _default = Orientation;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21tb24vbGlicy9sZm8vT3JpZW50YXRpb24uanMiXSwibmFtZXMiOlsiYWJzIiwiTWF0aCIsImF0YW4yIiwiY29zIiwic2luIiwic3FydCIsInBvdyIsInRhbiIsIm1heCIsInRvRGVnIiwiUEkiLCJ0b1JhZCIsIm5vcm1hbGl6ZSIsInYiLCJtYWciLCJwYXJhbWV0ZXJzIiwiayIsInR5cGUiLCJtaW4iLCJzdGVwIiwiZGVmYXVsdCIsIk9yaWVudGF0aW9uIiwiQmFzZUxmbyIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsInByb2Nlc3NTdHJlYW1QYXJhbXMiLCJwcmV2U3RyZWFtUGFyYW1zIiwicHJlcGFyZVN0cmVhbVBhcmFtcyIsInN0cmVhbVBhcmFtcyIsImZyYW1lU2l6ZSIsImluaXQiLCJsYXN0VGltZSIsImludGVydmFsIiwiYWNjVmVjdG9yIiwiRmxvYXQzMkFycmF5IiwiZ3lyb1ZlY3RvciIsImd5cm9Fc3RpbWF0ZSIsImFjY0VzdGltYXRlIiwicHJvcGFnYXRlU3RyZWFtUGFyYW1zIiwicHJvY2Vzc1ZlY3RvciIsImZyYW1lIiwidGltZSIsImlucHV0IiwiZGF0YSIsIm91dHB1dCIsInBhcmFtcyIsImdldCIsImFjY09mZnNldCIsImd5cm9PZmZzZXQiLCJpIiwiZHQiLCJyb2xsRGVsdGEiLCJyb2xsQW5nbGUiLCJwaXRjaERlbHRhIiwicGl0Y2hBbmdsZSIsInNpZ25ZYXciLCJneXJvRXN0aW1hdGVTcXVhcmVkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7QUFFQTtBQUNBLE1BQU1BLEdBQUcsR0FBR0MsSUFBSSxDQUFDRCxHQUFqQjtBQUNBLE1BQU1FLEtBQUssR0FBR0QsSUFBSSxDQUFDQyxLQUFuQjtBQUNBLE1BQU1DLEdBQUcsR0FBR0YsSUFBSSxDQUFDRSxHQUFqQjtBQUNBLE1BQU1DLEdBQUcsR0FBR0gsSUFBSSxDQUFDRyxHQUFqQjtBQUNBLE1BQU1DLElBQUksR0FBR0osSUFBSSxDQUFDSSxJQUFs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QUFDWSxDQUFELENBQVgsR0FBaUJoQixTQUFTLENBQUNnQixDQUFELENBQTFCO0FBQ0Q7QUFDRjtBQUNGOztBQUVETCxJQUFBQSxNQUFNLENBQUMsQ0FBRCxDQUFOLEdBQVlQLFdBQVcsQ0FBQyxDQUFELENBQXZCO0FBQ0FPLElBQUFBLE1BQU0sQ0FBQyxDQUFELENBQU4sR0FBWVAsV0FBVyxDQUFDLENBQUQsQ0FBdkI7QUFDQU8sSUFBQUEsTUFBTSxDQUFDLENBQUQsQ0FBTixHQUFZUCxXQUFXLENBQUMsQ0FBRCxDQUF2QjtBQUNEOztBQXhIK0I7O2VBMkhuQmhCLFciLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmFzZUxmbyBmcm9tICcuL0Jhc2VMZm8uanMnO1xuXG4vLyBwb3J0IG9mIG9yaWVudGF0aW9uLmNwcCBNYXggb2JqZWN0XG5jb25zdCBhYnMgPSBNYXRoLmFicztcbmNvbnN0IGF0YW4yID0gTWF0aC5hdGFuMjtcbmNvbnN0IGNvcyA9IE1hdGguY29zO1xuY29uc3Qgc2luID0gTWF0aC5zaW47XG5jb25zdCBzcXJ0ID0gTWF0aC5zcXJ0O1xuY29uc3QgcG93ID0gTWF0aC5wb3c7XG5jb25zdCB0YW4gPSBNYXRoLnRhbjtcbmNvbnN0IG1heCA9IE1hdGgubWF4O1xuXG5jb25zdCB0b0RlZyA9IDE4MCAvIE1hdGguUEk7XG5jb25zdCB0b1JhZCA9IE1hdGguUEkgLyAxODA7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZSh2KSB7XG4gIGNvbnN0IG1hZyA9IHNxcnQodlswXSAqIHZbMF0gKyB2WzFdICogdlsxXSArIHZbMl0gKiB2WzJdKTtcblxuICBpZiAobWFnID4gMCkge1xuICAgIHZbMF0gLz0gbWFnO1xuICAgIHZbMV0gLz0gbWFnO1xuICAgIHZbMl0gLz0gbWFnO1xuICB9XG5cbiAgcmV0dXJuIHY7XG59XG5cbmNvbnN0IHBhcmFtZXRlcnMgPSB7XG4gIGs6IHtcbiAgICB0eXBlOiAnZmxvYXQnLFxuICAgIG1pbjogMCxcbiAgICBtYXg6IDEsXG4gICAgc3RlcDogMC4wMSxcbiAgICBkZWZhdWx0OiAwLjksXG4gIH0sXG59O1xuXG4vKipcbiAqIEZpbHRlciB0aGF0IGludGVncmF0ZSBneXJvc3Njb3BlIGFuZCBhY2NlbGVyYXRpb24gaW4gb3JkZXIgdG8gcmVtb3ZlIG5vaXNlXG4gKiBmcm9tIGFjY2VsZXJvbWV0ZXJzIGRhdGEgd2hpbGUga2VlcGluZyBhIGdvb2QgcmVhY3Rpdml0eS5cbiAqIFRoZSBmaWx0ZXIgb3VwdXRzIGEgbm9ybWFsaXplZCBwcm9qZWN0aW9uIHZlY3Rvci5cbiAqIEJlIGF3YXJlIHRoYXQgdGhlIG91dCBvZiB0aGUgZmlsdGVyIGludmVydCB0aGUgeCBhbmQgeiBpbiByZWdhcmQgb2YgdGhlXG4gKiBkZXZpY2UgbW90aW9uIHNwZWNpZmljYXRpb24gKGxlZnQtaGFuZCBheGlzKS4gVGhpcyBpcyBkb25lIGZvciBjb21wYXRpYmlsaXR5XG4gKiB3aXRoIHRoZSBSLWlvVCBzZW5zb3IuXG4gKlxuICogQG1lbWJlcm9mIG9wZXJhdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE92ZXJyaWRlIGRlZmF1bHQgb3B0aW9ucy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5rPTAuOV0gLSBSYXRpbyBiZXR3ZWVuIHRoZSBhY2NlbGVyb21ldGVycyBhbmQgZ3lyb3Njb3BlLlxuICogIDEgbWVhbnMgZ3lyb3Njb3BlIG9ubHlcbiAqICAwIG1lYW4gYWNjZWxlcm9tZXRlcnMgb25seSAodGhpcyBpcyBlcXVpdmFsZW50IHRvIGEgbG93cGFzcyBmaWx0ZXIpXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCAqIGFzIGxmbyBmcm9tICd3YXZlcy1sZm8vY2xpZW50JztcbiAqIGltcG9ydCAqIGFzIGxmb01vdGlvbiBmcm9tICdsZm8tbW90aW9uJztcbiAqXG4gKiBjb25zdCBtb3Rpb25JbnB1dCA9IG5ldyBsZm9Nb3Rpb24uc291cmNlLk1vdGlvbklucHV0KCk7XG4gKiBjb25zdCBzYW1wbGVyID0gbmV3IGxmb01vdGlvbi5vcGVyYXRvci5TYW1wbGVyKHsgZnJhbWVSYXRlOiA1MCB9KTtcbiAqIGNvbnN0IG9yaWVudGF0aW9uID0gbmV3IGxmb01vdGlvbi5vcGVyYXRvci5PcmllbnRhdGlvbigpO1xuICogY29uc3QgbG9nZ2VyID0gbmV3IGxmby5zaW5rLkxvZ2dlcih7IGRhdGE6IHRydWUgfSk7XG4gKlxuICogbW90aW9uSW5wdXQuY29ubmVjdChzYW1wbGVyKTtcbiAqIHNhbXBsZXIuY29ubmVjdChvcmllbnRhdGlvbik7XG4gKiBvcmllbnRhdGlvbi5jb25uZWN0KGxvZ2dlcik7XG4gKlxuICogbW90aW9uSW5wdXQuaW5pdCgpLnRoZW4oKCkgPT4gbW90aW9uSW5wdXQuc3RhcnQoKSlcbiAqL1xuY2xhc3MgT3JpZW50YXRpb24gZXh0ZW5kcyBCYXNlTGZvIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHByb2Nlc3NTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcykge1xuICAgIHRoaXMucHJlcGFyZVN0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKTtcblxuICAgIHRoaXMuc3RyZWFtUGFyYW1zLmZyYW1lU2l6ZSA9IDM7XG5cbiAgICB0aGlzLmluaXQgPSBmYWxzZTtcbiAgICB0aGlzLmxhc3RUaW1lID0gMDtcbiAgICB0aGlzLmludGVydmFsID0gMDtcbiAgICAvLyB0aGlzLmsgPSAwLjk7XG5cbiAgICAvLyBub3JtYWxpemVkIGFjY2VsZXJhdGlvbiB2ZWN0b3JcbiAgICAvLyBjb29yZGluYXRlcyBhcmUgZmxpcHBlZCB0byBtYXRjaCBSLWlvVCBjb29yZHMgc3lzdGVtXG4gICAgdGhpcy5hY2NWZWN0b3IgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgIC8vIG5vcm1hbGl6ZSBneXJvIG9yZGVyIGFuZCBkaXJlY3Rpb24gYWNjb3JkaW5nIHRvIFItaW9UXG4gICAgdGhpcy5neXJvVmVjdG9yID0gbmV3IEZsb2F0MzJBcnJheSgzKTsgLy8gdGhpcmQgY29tcG9uZW50ICh5YXcpIHdpbGwgbmV2ZXIgYmUgdXNlZFxuICAgIC8vIHNhbWUgYXMgYmVmb3JlIGFzIGEgcHJvamVjdGlvbiB2ZWN0b3JcbiAgICB0aGlzLmd5cm9Fc3RpbWF0ZSA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgLy8gZmlsdGVyZWQgdmVjdG9yXG4gICAgdGhpcy5hY2NFc3RpbWF0ZSA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG5cblxuICAgIHRoaXMucHJvcGFnYXRlU3RyZWFtUGFyYW1zKCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcHJvY2Vzc1ZlY3RvcihmcmFtZSkge1xuICAgIGNvbnN0IHRpbWUgPSBmcmFtZS50aW1lO1xuICAgIGNvbnN0IGlucHV0ID0gZnJhbWUuZGF0YTtcbiAgICBjb25zdCBvdXRwdXQgPSB0aGlzLmZyYW1lLmRhdGE7XG4gICAgY29uc3QgYWNjRXN0aW1hdGUgPSB0aGlzLmFjY0VzdGltYXRlO1xuICAgIGNvbnN0IGd5cm9Fc3RpbWF0ZSA9IHRoaXMuZ3lyb0VzdGltYXRlO1xuXG4gICAgY29uc3QgayA9IHRoaXMucGFyYW1zLmdldCgnaycpO1xuXG4gICAgLyoqXG4gICAgICogUmVvcmRlciBhY2NlbGVyb21ldGVyIGFuZCBneXJvIHRvIGNvbmZvcm0gdG8gUi1pb1RcbiAgICAgKiBjb29yZGluYXRlIHN5c3RlbSBhbmQgZ3lybyBkaXJlY3Rpb25zXG4gICAgICovXG4gICAgY29uc3QgYWNjVmVjdG9yID0gdGhpcy5hY2NWZWN0b3I7XG4gICAgY29uc3QgYWNjT2Zmc2V0ID0gMDtcbiAgICBhY2NWZWN0b3JbMF0gPSAtMSAqIGlucHV0WzAgKyBhY2NPZmZzZXRdO1xuICAgIGFjY1ZlY3RvclsxXSA9ICAxICogaW5wdXRbMSArIGFjY09mZnNldF07XG4gICAgYWNjVmVjdG9yWzJdID0gLTEgKiBpbnB1dFsyICsgYWNjT2Zmc2V0XTtcblxuICAgIGNvbnN0IGd5cm9WZWN0b3IgPSB0aGlzLmd5cm9WZWN0b3I7XG4gICAgY29uc3QgZ3lyb09mZnNldCA9IDM7XG4gICAgZ3lyb1ZlY3RvclswXSA9IC0xICogaW5wdXRbMiArIGd5cm9PZmZzZXRdO1xuICAgIGd5cm9WZWN0b3JbMV0gPSAtMSAqIGlucHV0WzEgKyBneXJvT2Zmc2V0XTtcbiAgICBneXJvVmVjdG9yWzJdID0gLTEgKiBpbnB1dFswICsgZ3lyb09mZnNldF07XG5cbiAgICBub3JtYWxpemUoYWNjVmVjdG9yKTtcblxuICAgIGlmICghdGhpcy5sYXN0VGltZSkge1xuICAgICAgdGhpcy5sYXN0VGltZSA9IHRpbWU7XG4gICAgICAvLyBpbml0aWFsaXplIGNvcnJlY3RlZCBvcmllbnRhdGlvbiB3aXRoIG5vcm1hbGl6ZWQgYWNjZWxlcm9tZXRlciBkYXRhXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICBhY2NFc3RpbWF0ZVtpXSA9IGFjY1ZlY3RvcltpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkZWZpbmUgaWYgd2UgdXNlIHRoYXQgb3IgdXNlIHRoZSBsb2dpY2FsIGBNb3Rpb25FdmVudC5pbnRlcnZhbGBcbiAgICAgIGNvbnN0IGR0ID0gdGltZSAtIHRoaXMubGFzdFRpbWU7XG5cbiAgICAgIHRoaXMubGFzdFRpbWUgPSB0aW1lO1xuXG4gICAgICAvLyBpbnRlZ3JhdGUgYW5nbGUgZnJvbSBneXJvIGN1cnJlbnQgdmFsdWVzIGFuZCBsYXN0IHJlc3VsdFxuICAgICAgLy8gZ2V0IGFuZ2xlcyBiZXR3ZWVuIHByb2plY3Rpb24gb2YgUiBvbiBaWC9aWSBwbGFuZSBhbmQgWiBheGlzLCBiYXNlZCBvbiBsYXN0IGFjY0VzdGltYXRlXG5cbiAgICAgIC8vIGd5cm9WZWN0b3IgaW4gZGVnL3MsIGRlbHRhIGFuZCBhbmdsZSBpbiByYWRcbiAgICAgIGNvbnN0IHJvbGxEZWx0YSA9IGd5cm9WZWN0b3JbMF0gKiBkdCAqIHRvUmFkO1xuICAgICAgY29uc3Qgcm9sbEFuZ2xlID0gYXRhbjIoYWNjRXN0aW1hdGVbMF0sIGFjY0VzdGltYXRlWzJdKSArIHJvbGxEZWx0YTtcblxuICAgICAgY29uc3QgcGl0Y2hEZWx0YSA9IGd5cm9WZWN0b3JbMV0gKiBkdCAqIHRvUmFkO1xuICAgICAgY29uc3QgcGl0Y2hBbmdsZSA9IGF0YW4yKGFjY0VzdGltYXRlWzFdLCBhY2NFc3RpbWF0ZVsyXSkgKyBwaXRjaERlbHRhO1xuXG4gICAgICAvLyBjYWxjdWxhdGUgcHJvamVjdGlvbiB2ZWN0b3IgZnJvbSBhbmdsZSBFc3RpbWF0ZXNcbiAgICAgIGd5cm9Fc3RpbWF0ZVswXSA9IHNpbihyb2xsQW5nbGUpO1xuICAgICAgZ3lyb0VzdGltYXRlWzBdIC89IHNxcnQoMSArIHBvdyhjb3Mocm9sbEFuZ2xlKSwgMikgKiBwb3codGFuKHBpdGNoQW5nbGUpLCAyKSk7XG5cbiAgICAgIGd5cm9Fc3RpbWF0ZVsxXSA9IHNpbihwaXRjaEFuZ2xlKTtcbiAgICAgIGd5cm9Fc3RpbWF0ZVsxXSAvPSBzcXJ0KDEgKyBwb3coY29zKHBpdGNoQW5nbGUpLCAyKSAqIHBvdyh0YW4ocm9sbEFuZ2xlKSwgMikpO1xuXG4gICAgICAvLyBlc3RpbWF0ZSBzaWduIG9mIFJ6R3lybyBieSBsb29raW5nIGluIHdoYXQgcXVkcmFudCB0aGUgYW5nbGUgQXh6IGlzLFxuICAgICAgLy8gUnpHeXJvIGlzIHBvc2l0aXZlIGlmICBBeHogaW4gcmFuZ2UgLTkwIC4uOTAgPT4gY29zKEF3eikgPj0gMFxuICAgICAgY29uc3Qgc2lnbllhdyA9IGNvcyhyb2xsQW5nbGUpID49IDAgPyAxIDogLTE7XG5cbiAgICAgIC8vIGVzdGltYXRlIHlhdyBzaW5jZSB2ZWN0b3IgaXMgbm9ybWFsaXplZFxuICAgICAgY29uc3QgZ3lyb0VzdGltYXRlU3F1YXJlZCA9IHBvdyhneXJvRXN0aW1hdGVbMF0sIDIpICsgcG93KGd5cm9Fc3RpbWF0ZVsxXSwgMik7XG5cbiAgICAgIGd5cm9Fc3RpbWF0ZVsyXSA9IHNpZ25ZYXcgKiBzcXJ0KG1heCgwLCAxIC0gZ3lyb0VzdGltYXRlU3F1YXJlZCkpO1xuXG4gICAgICAvLyBpbnRlcnBvbGF0ZSBiZXR3ZWVuIGVzdGltYXRlZCB2YWx1ZXMgYW5kIHJhdyB2YWx1ZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIGFjY0VzdGltYXRlW2ldID0gZ3lyb0VzdGltYXRlW2ldICogayArIGFjY1ZlY3RvcltpXSAqICgxIC0gayk7XG4gICAgICB9XG5cbiAgICAgIG5vcm1hbGl6ZShhY2NFc3RpbWF0ZSk7XG5cbiAgICAgIC8vIFJ6IGlzIHRvbyBzbWFsbCBhbmQgYmVjYXVzZSBpdCBpcyB1c2VkIGFzIHJlZmVyZW5jZSBmb3IgY29tcHV0aW5nIEF4eiwgQXl6XG4gICAgICAvLyBpdCdzIGVycm9yIGZsdWN0dWF0aW9ucyB3aWxsIGFtcGxpZnkgbGVhZGluZyB0byBiYWQgcmVzdWx0cy4gSW4gdGhpcyBjYXNlXG4gICAgICAvLyBza2lwIHRoZSBneXJvIGRhdGEgYW5kIGp1c3QgdXNlIHByZXZpb3VzIGVzdGltYXRlXG4gICAgICBpZiAoYWJzKGFjY0VzdGltYXRlWzJdKSA8IDAuMSkge1xuICAgICAgICAvLyB1c2UgaW5wdXQgaW5zdGVhZCBvZiBlc3RpbWF0aW9uXG4gICAgICAgIC8vIGFjY1ZlY3RvciBpcyBhbHJlYWR5IG5vcm1hbGl6ZWRcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGk8IDM7IGkrKykge1xuICAgICAgICAgIGFjY0VzdGltYXRlW2ldID0gYWNjVmVjdG9yW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgb3V0cHV0WzBdID0gYWNjRXN0aW1hdGVbMF07XG4gICAgb3V0cHV0WzFdID0gYWNjRXN0aW1hdGVbMV07XG4gICAgb3V0cHV0WzJdID0gYWNjRXN0aW1hdGVbMl07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgT3JpZW50YXRpb247XG4iXX0=