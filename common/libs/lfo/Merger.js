"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _BaseLfo = _interopRequireDefault(require("./BaseLfo.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const definitions = {
  // array defining the frameSizes of the input streamss
  // e.g. if [3, 2, 1], we wait for 3 different sources of respective 3, 2, 1 frameSizes
  frameSizes: {
    type: 'any',
    default: null,
    constant: true
  }
};
/**
 * Merge multiple vector frames. The order of execution depends on the
 * order the branching was initially made. The first branche is master
 * on the time and trigger the output of the frame.
 *
 * @memberof module:common.operator
 *
 * @param {Object} options - Override default parameters
 * @param {Array} [options.frameSizes=null] - Array that defines the number
 *  of values to pick from each incomming vectors.
 *
 * @example
 * import * as lfo from 'waves-lfo/comon'
 *
 * const eventIn = new lfo.operator.EventIn({
 *   type: 'vector',
 *   frameSize: 4,
 *   frameRate: 0,
 * });
 *
 * const minMax = new lfo.operator.MinMax();
 * const magnitude = new lfo.operator.Magnitude();
 *
 * // take the first 2 values of the first branch and 1 value from the second branch
 * const merge = new lfo.operator.Merger({ frameSizes: [2, 1] });
 *
 * // this defines the order in which Merger will be called
 * eventIn.connect(minMax);
 * eventIn.connect(magnitude);
 *
 * minMax.connect(merger);
 * magnitude.connect(merger);
 */

class Merger extends _BaseLfo.default {
  constructor(options) {
    super(definitions, options);
  }

  processStreamParams(prevStreamParams) {
    this.prepareStreamParams(prevStreamParams); // ...

    const frameSizes = this.params.get('frameSizes');
    const numSources = frameSizes.length;
    let frameSize = 0;

    for (let i = 0; i < numSources; i++) frameSize += frameSizes[i];

    this.streamParams.frameSize = frameSize;
    this.numSources = numSources;
    this.sourceIndex = 0;
    this.propagateStreamParams();
  }

  processVector() {} // processSignal() {} // makes no sens to merge signals (maybe MUX / DEMUX)


  processFrame(frame) {
    const currentIndex = this.sourceIndex;
    const frameSizes = this.params.get('frameSizes');
    const numSources = frameSizes.length;
    const input = frame.data;
    const output = this.frame.data; // first source define time

    if (currentIndex === 0) this.frame.time = frame.time;
    const currentFrameSize = frameSizes[currentIndex];
    let offset = 0;

    for (let i = 0; i < currentIndex; i++) offset += frameSizes[i]; // copy data


    for (let i = 0; i < currentFrameSize; i++) output[offset + i] = input[i];

    this.sourceIndex = (this.sourceIndex + 1) % numSources; // we just received the last input, output the frame

    if (this.sourceIndex === 0) this.propagateFrame();
  }

}

var _default = Merger;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21tb24vbGlicy9sZm8vTWVyZ2VyLmpzIl0sIm5hbWVzIjpbImRlZmluaXRpb25zIiwiZnJhbWVTaXplcyIsInR5cGUiLCJkZWZhdWx0IiwiY29uc3RhbnQiLCJNZXJnZXIiLCJCYXNlTGZvIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwicHJvY2Vzc1N0cmVhbVBhcmFtcyIsInByZXZTdHJlYW1QYXJhbXMiLCJwcmVwYXJlU3RyZWFtUGFyYW1zIiwicGFyYW1zIiwiZ2V0IiwibnVtU291cmNlcyIsImxlbmd0aCIsImZyYW1lU2l6ZSIsImkiLCJzdHJlYW1QYXJhbXMiLCJzb3VyY2VJbmRleCIsInByb3BhZ2F0ZVN0cmVhbVBhcmFtcyIsInByb2Nlc3NWZWN0b3IiLCJwcm9jZXNzRnJhbWUiLCJmcmFtZSIsImN1cnJlbnRJbmRleCIsImlucHV0IiwiZGF0YSIsIm91dHB1dCIsInRpbWUiLCJjdXJyZW50RnJhbWVTaXplIiwib2Zmc2V0IiwicHJvcGFnYXRlRnJhbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7OztBQUVBLE1BQU1BLFdBQVcsR0FBRztBQUNsQjtBQUNBO0FBQ0FDLEVBQUFBLFVBQVUsRUFBRTtBQUNWQyxJQUFBQSxJQUFJLEVBQUUsS0FESTtBQUVWQyxJQUFBQSxPQUFPLEVBQUUsSUFGQztBQUdWQyxJQUFBQSxRQUFRLEVBQUU7QUFIQTtBQUhNLENBQXBCO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLE1BQU1DLE1BQU4sU0FBcUJDLGdCQUFyQixDQUE2QjtBQUMzQkMsRUFBQUEsV0FBVyxDQUFDQyxPQUFELEVBQVU7QUFDbkIsVUFBTVIsV0FBTixFQUFtQlEsT0FBbkI7QUFDRDs7QUFFREMsRUFBQUEsbUJBQW1CLENBQUNDLGdCQUFELEVBQW1CO0FBQ3BDLFNBQUtDLG1CQUFMLENBQXlCRCxnQkFBekIsRUFEb0MsQ0FHcEM7O0FBQ0EsVUFBTVQsVUFBVSxHQUFHLEtBQUtXLE1BQUwsQ0FBWUMsR0FBWixDQUFnQixZQUFoQixDQUFuQjtBQUNBLFVBQU1DLFVBQVUsR0FBR2IsVUFBVSxDQUFDYyxNQUE5QjtBQUVBLFFBQUlDLFNBQVMsR0FBRyxDQUFoQjs7QUFDQSxTQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdILFVBQXBCLEVBQWdDRyxDQUFDLEVBQWpDLEVBQ0VELFNBQVMsSUFBSWYsVUFBVSxDQUFDZ0IsQ0FBRCxDQUF2Qjs7QUFHRixTQUFLQyxZQUFMLENBQWtCRixTQUFsQixHQUE4QkEsU0FBOUI7QUFDQSxTQUFLRixVQUFMLEdBQWtCQSxVQUFsQjtBQUNBLFNBQUtLLFdBQUwsR0FBbUIsQ0FBbkI7QUFFQSxTQUFLQyxxQkFBTDtBQUNEOztBQUVEQyxFQUFBQSxhQUFhLEdBQUcsQ0FBRSxDQXhCUyxDQXlCM0I7OztBQUVBQyxFQUFBQSxZQUFZLENBQUNDLEtBQUQsRUFBUTtBQUNsQixVQUFNQyxZQUFZLEdBQUcsS0FBS0wsV0FBMUI7QUFDQSxVQUFNbEIsVUFBVSxHQUFHLEtBQUtXLE1BQUwsQ0FBWUMsR0FBWixDQUFnQixZQUFoQixDQUFuQjtBQUNBLFVBQU1DLFVBQVUsR0FBR2IsVUFBVSxDQUFDYyxNQUE5QjtBQUNBLFVBQU1VLEtBQUssR0FBR0YsS0FBSyxDQUFDRyxJQUFwQjtBQUNBLFVBQU1DLE1BQU0sR0FBRyxLQUFLSixLQUFMLENBQVdHLElBQTFCLENBTGtCLENBT2xCOztBQUNBLFFBQUlGLFlBQVksS0FBSyxDQUFyQixFQUNFLEtBQUtELEtBQUwsQ0FBV0ssSUFBWCxHQUFrQkwsS0FBSyxDQUFDSyxJQUF4QjtBQUVGLFVBQU1DLGdCQUFnQixHQUFHNUIsVUFBVSxDQUFDdUIsWUFBRCxDQUFuQztBQUNBLFFBQUlNLE1BQU0sR0FBRyxDQUFiOztBQUVBLFNBQUssSUFBSWIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR08sWUFBcEIsRUFBa0NQLENBQUMsRUFBbkMsRUFDRWEsTUFBTSxJQUFJN0IsVUFBVSxDQUFDZ0IsQ0FBRCxDQUFwQixDQWZnQixDQWlCbEI7OztBQUNBLFNBQUssSUFBSUEsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR1ksZ0JBQXBCLEVBQXNDWixDQUFDLEVBQXZDLEVBQ0VVLE1BQU0sQ0FBQ0csTUFBTSxHQUFHYixDQUFWLENBQU4sR0FBcUJRLEtBQUssQ0FBQ1IsQ0FBRCxDQUExQjs7QUFFRixTQUFLRSxXQUFMLEdBQW1CLENBQUMsS0FBS0EsV0FBTCxHQUFtQixDQUFwQixJQUF5QkwsVUFBNUMsQ0FyQmtCLENBdUJsQjs7QUFDQSxRQUFJLEtBQUtLLFdBQUwsS0FBcUIsQ0FBekIsRUFDRSxLQUFLWSxjQUFMO0FBQ0g7O0FBckQwQjs7ZUF3RGQxQixNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2VMZm8gZnJvbSAnLi9CYXNlTGZvLmpzJztcblxuY29uc3QgZGVmaW5pdGlvbnMgPSB7XG4gIC8vIGFycmF5IGRlZmluaW5nIHRoZSBmcmFtZVNpemVzIG9mIHRoZSBpbnB1dCBzdHJlYW1zc1xuICAvLyBlLmcuIGlmIFszLCAyLCAxXSwgd2Ugd2FpdCBmb3IgMyBkaWZmZXJlbnQgc291cmNlcyBvZiByZXNwZWN0aXZlIDMsIDIsIDEgZnJhbWVTaXplc1xuICBmcmFtZVNpemVzOiB7XG4gICAgdHlwZTogJ2FueScsXG4gICAgZGVmYXVsdDogbnVsbCxcbiAgICBjb25zdGFudDogdHJ1ZSxcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIG11bHRpcGxlIHZlY3RvciBmcmFtZXMuIFRoZSBvcmRlciBvZiBleGVjdXRpb24gZGVwZW5kcyBvbiB0aGVcbiAqIG9yZGVyIHRoZSBicmFuY2hpbmcgd2FzIGluaXRpYWxseSBtYWRlLiBUaGUgZmlyc3QgYnJhbmNoZSBpcyBtYXN0ZXJcbiAqIG9uIHRoZSB0aW1lIGFuZCB0cmlnZ2VyIHRoZSBvdXRwdXQgb2YgdGhlIGZyYW1lLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tbW9uLm9wZXJhdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZSBkZWZhdWx0IHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmZyYW1lU2l6ZXM9bnVsbF0gLSBBcnJheSB0aGF0IGRlZmluZXMgdGhlIG51bWJlclxuICogIG9mIHZhbHVlcyB0byBwaWNrIGZyb20gZWFjaCBpbmNvbW1pbmcgdmVjdG9ycy5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0ICogYXMgbGZvIGZyb20gJ3dhdmVzLWxmby9jb21vbidcbiAqXG4gKiBjb25zdCBldmVudEluID0gbmV3IGxmby5vcGVyYXRvci5FdmVudEluKHtcbiAqICAgdHlwZTogJ3ZlY3RvcicsXG4gKiAgIGZyYW1lU2l6ZTogNCxcbiAqICAgZnJhbWVSYXRlOiAwLFxuICogfSk7XG4gKlxuICogY29uc3QgbWluTWF4ID0gbmV3IGxmby5vcGVyYXRvci5NaW5NYXgoKTtcbiAqIGNvbnN0IG1hZ25pdHVkZSA9IG5ldyBsZm8ub3BlcmF0b3IuTWFnbml0dWRlKCk7XG4gKlxuICogLy8gdGFrZSB0aGUgZmlyc3QgMiB2YWx1ZXMgb2YgdGhlIGZpcnN0IGJyYW5jaCBhbmQgMSB2YWx1ZSBmcm9tIHRoZSBzZWNvbmQgYnJhbmNoXG4gKiBjb25zdCBtZXJnZSA9IG5ldyBsZm8ub3BlcmF0b3IuTWVyZ2VyKHsgZnJhbWVTaXplczogWzIsIDFdIH0pO1xuICpcbiAqIC8vIHRoaXMgZGVmaW5lcyB0aGUgb3JkZXIgaW4gd2hpY2ggTWVyZ2VyIHdpbGwgYmUgY2FsbGVkXG4gKiBldmVudEluLmNvbm5lY3QobWluTWF4KTtcbiAqIGV2ZW50SW4uY29ubmVjdChtYWduaXR1ZGUpO1xuICpcbiAqIG1pbk1heC5jb25uZWN0KG1lcmdlcik7XG4gKiBtYWduaXR1ZGUuY29ubmVjdChtZXJnZXIpO1xuICovXG5jbGFzcyBNZXJnZXIgZXh0ZW5kcyBCYXNlTGZvIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKGRlZmluaXRpb25zLCBvcHRpb25zKTtcbiAgfVxuXG4gIHByb2Nlc3NTdHJlYW1QYXJhbXMocHJldlN0cmVhbVBhcmFtcykge1xuICAgIHRoaXMucHJlcGFyZVN0cmVhbVBhcmFtcyhwcmV2U3RyZWFtUGFyYW1zKTtcblxuICAgIC8vIC4uLlxuICAgIGNvbnN0IGZyYW1lU2l6ZXMgPSB0aGlzLnBhcmFtcy5nZXQoJ2ZyYW1lU2l6ZXMnKTtcbiAgICBjb25zdCBudW1Tb3VyY2VzID0gZnJhbWVTaXplcy5sZW5ndGg7XG5cbiAgICBsZXQgZnJhbWVTaXplID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVNvdXJjZXM7IGkrKylcbiAgICAgIGZyYW1lU2l6ZSArPSBmcmFtZVNpemVzW2ldO1xuXG5cbiAgICB0aGlzLnN0cmVhbVBhcmFtcy5mcmFtZVNpemUgPSBmcmFtZVNpemU7XG4gICAgdGhpcy5udW1Tb3VyY2VzID0gbnVtU291cmNlcztcbiAgICB0aGlzLnNvdXJjZUluZGV4ID0gMDtcblxuICAgIHRoaXMucHJvcGFnYXRlU3RyZWFtUGFyYW1zKCk7XG4gIH1cblxuICBwcm9jZXNzVmVjdG9yKCkge31cbiAgLy8gcHJvY2Vzc1NpZ25hbCgpIHt9IC8vIG1ha2VzIG5vIHNlbnMgdG8gbWVyZ2Ugc2lnbmFscyAobWF5YmUgTVVYIC8gREVNVVgpXG5cbiAgcHJvY2Vzc0ZyYW1lKGZyYW1lKSB7XG4gICAgY29uc3QgY3VycmVudEluZGV4ID0gdGhpcy5zb3VyY2VJbmRleDtcbiAgICBjb25zdCBmcmFtZVNpemVzID0gdGhpcy5wYXJhbXMuZ2V0KCdmcmFtZVNpemVzJyk7XG4gICAgY29uc3QgbnVtU291cmNlcyA9IGZyYW1lU2l6ZXMubGVuZ3RoO1xuICAgIGNvbnN0IGlucHV0ID0gZnJhbWUuZGF0YTtcbiAgICBjb25zdCBvdXRwdXQgPSB0aGlzLmZyYW1lLmRhdGE7XG5cbiAgICAvLyBmaXJzdCBzb3VyY2UgZGVmaW5lIHRpbWVcbiAgICBpZiAoY3VycmVudEluZGV4ID09PSAwKVxuICAgICAgdGhpcy5mcmFtZS50aW1lID0gZnJhbWUudGltZTtcblxuICAgIGNvbnN0IGN1cnJlbnRGcmFtZVNpemUgPSBmcmFtZVNpemVzW2N1cnJlbnRJbmRleF07XG4gICAgbGV0IG9mZnNldCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnRJbmRleDsgaSsrKVxuICAgICAgb2Zmc2V0ICs9IGZyYW1lU2l6ZXNbaV07XG5cbiAgICAvLyBjb3B5IGRhdGFcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnRGcmFtZVNpemU7IGkrKylcbiAgICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IGlucHV0W2ldO1xuXG4gICAgdGhpcy5zb3VyY2VJbmRleCA9ICh0aGlzLnNvdXJjZUluZGV4ICsgMSkgJSBudW1Tb3VyY2VzO1xuXG4gICAgLy8gd2UganVzdCByZWNlaXZlZCB0aGUgbGFzdCBpbnB1dCwgb3V0cHV0IHRoZSBmcmFtZVxuICAgIGlmICh0aGlzLnNvdXJjZUluZGV4ID09PSAwKVxuICAgICAgdGhpcy5wcm9wYWdhdGVGcmFtZSgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1lcmdlcjtcbiJdfQ==